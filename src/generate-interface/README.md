# Notes

## Compiling LAPACK from Fortran to Lisp

We rely on F2CL to compile Fortran LAPACK code to Lisp. However, a
number of hacks were needed in order to make this work. We list these
below:

1. By default, LAPACK sources were taken from the LAPACK 3.5.0
release. This was chosen because later versions include some revisions
to key routines which F2CL cannot handle (e.g. in LAPACK 3.6.0 the
implementation of ZGETRF relies on a recursive implementation ZGETRF2,
but F2CL is not presently capable of compiling recursive subroutines).

2. Several of these sources still rely on certain Fortra features that
F2CL can't handle. One particularly difficult issue is the use of
Fortran `EQUIVALENCE`. This is essentially a declaration that memory
certain references should be aliased. F2CL handles it via
`SYMBOL-MACROLET` which can only be made to work where one of the
aliases is a Fortran variable; in particular, there is no easy way to
handle array aliasing. The F2CL test suite has some LAPACK files which
have been hacked up to remove these usages of `EQUIVALENCE`, so on top
of the LAPACK 3.5.0 sources we use all of the LAPACK files found here:
[https://gitlab.common-lisp.net/f2cl/f2cl/-/tree/master/packages/lapack](https://gitlab.common-lisp.net/f2cl/f2cl/-/tree/master/packages/lapack)

3. As a last exception to the above, we use ZGESVD from LAPACK 3.6.0,
due to the inclusion of a necessary bugfix
(cf. http://icl.utk.edu/lapack-forum/viewtopic.php?f=13&t=4392).

4. We delete `xerbla_array.f` in `BLAS/SRC/`, delete `xerbla*.f` in
`SRC/`, and leave only `dlamch.f` in `INSTALL/`. The removed routines
are not needed and some (e.g. `xerbla_array.f`) cause F2CL to fail.

5. When compiling with F2CL, it is important that callees are known to
F2CL at their call sites. To ensure this, the Lisp code sorts through
Fortran dependencies to resolve compilation order. These dependencies
are known from the `EXTERNAL` declarations in the corresponding
Fortran subroutines; however a few routines use `DLABAD` without
declaring it as external, so we hardcode this dependency
(cf. `*lapack-entry-points*`).

6. A common convention in LAPACK code is to pass arbitrary length
strings to subroutines which expect a length 1 string, e.g. 'Rowwise'
where 'R' is expected. This is seemingly tolerated by Fortran
compilers, but SBCL does not like this since it violates type
declarations in F2CL's output. Hence we maintain an explicit list of
string which should be truncated (cf. `*lapack-long-strings*`) and
hack `F2CL::*F2CL-PPRINT-DISPATCH*` to abbreviate these in the code it
generated by F2CL.

7. LAPACK's `dlamch.f` uses some Fortran 90 intrinsics which F2CL
doesn't know about. These are not needed for compilation, but are
needed for execution, and so we define these explicitly in
`magicl/lapack/fortran-intrinsics.lisp`.